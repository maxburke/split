<html>

	<head>
		<meta http-equiv="content-type" content="text/html;charset=iso-8859-1">
		<meta name="generator" content="Adobe GoLive 4">
		<title>Quake III Arena Shader Manual - Section 6 - Stage Specific Keywords</title>
		<style type="text/css"><!--
			a { color: #880002; text-decoration: none }
			a:hover { color: #ff0003; text-decoration: underline }-->
		</style>
	</head>

	<body bgcolor="white">
		<center>
			<font size="2" face="Arial"><a name="6"></a>Quake III Arena Shader Manual Revision #12<br>
			By <a href="mailto:paulj@idsoftware.com?subject=Q3A Shader Manual">Paul Jaquays</a> and <a href="mailto:bwh@idsoftware.com?subject=Q3A Shader Manual">Brian Hook</a><br>
			(with additional material by <a href="http://www.idsoftware.com/" target="_blank">John Carmack, Christian Antkow, Kevin Cloud, &amp; Adrian Carmack</a>)</font></center>
		<p>
		<hr>
		</p>
		<center>
			<p><a href="section5.htm#5"><font face="Arial" size="2">Previous</font></a><font face="Arial" size="2"> &nbsp;&nbsp;&nbsp;&nbsp; <a href="index.html">Index</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="section7.htm#7">Next</a></font></p>
		</center>
		<p>
		<hr>
		</p>
		<p><font size="4" face="Arial"><b>6. Stage Specific Keywords</b></font><font size="2" face="Arial"><br>
		Stage specifications only affect rendering. Changing any keywords or values within a stage will usually take effect as soon as a vid_restart is executed. Q3MAP ignores stage specific keywords entirely.</font></p>
		<p><font size="2" face="Arial">A stage can specify a texture map, a color function, an alpha function, a texture coordinate function, a blend function, and a few other rasterization options.</font></p>
		<p><font face="Arial"><i><b><a name="6.1"></a>6.1 Texture map specification</b></i></font><font size="2" face="Arial"><br>
		</font></p>
		<p><font size="2" face="Arial"><b><a name="6.1.1"></a>6.1.1 map &lt;texturepath/texturename&gt;</b><br>
		Specifies the source texture map (a 24 or 32-bit TGA file) used for this stage. The texture may or may not contain alpha channel information. The special keywords <b>$lightmap</b> and <b>$whiteimage</b> may be substituted in lieu of an actual texture map name. In those cases, the texture named in the first line of the shader becomes the texture that supplies the light mapping data for the process.</font></p>
		<p><font size="2" face="Arial"><b>$lightmap</b><br>
		This is the overall lightmap for the game world. It is calculated during the Q3MAP process. It is the initial color data found in the framebuffer. Note: due to the use of overbright bits in light calculation, the keyword <b>rgbGen identity</b> must accompany all <b>$lightmap</b> instructions.</font></p>
		<p><font size="2" face="Arial"><b>$whiteimage</b><br>
		This is used for specular lighting on MD3 models. This is is a white image generated internally by the game. This image can be used in lieu of $lightmap or an actual texture map if, for example, you wish for the vertex colors to come through unaltered.</font></p>
		<p><font size="2" face="Arial"><b><a name="6.1.2"></a>6.1.2 Clampmap &lt;texturepath&gt;</b><br>
		Dictates that this stage should clamp texture coordinates instead of wrapping them. During a stretch function, the area, which the texture must cover during a wave cycle, enlarges and decreases. Instead of repeating a texture multiple times during enlargement (or seeing only a portion of the texture during shrinking) the texture dimensions increase or contract accordingly. This is only relevant when using something like deformTexCoordParms to stretch/compress texture coordinates for a specific special effect. Remember that the Quake III Arena engine normalizes all texture coordinates (regardless of actual texture size) into a scale of 0.0 to 1.0.</font></p>
		<p><font size="2" face="Arial"><b>Proper Alignment:</b> When using <b>clampTexCoords</b> be make sure the texture is properly aligned on the brush. The <b>clampTexCoords</b> function keeps the image from tiling. However, the editor doesn't represent this properly and shows a tiled image. Therefore, what appears to be the correct position may be offset. This is very apparent on anything with a <b>tcMod rotate</b> and <b>clampTexCoords</b> function.</font></p>
		<p><font size="2" face="Arial"><b>Avoiding Distortion:</b> When seen at a given distance (which can vary, depending on hardware and the size of the texture), the compression phase of a stretch function will cause a &quot;cross&quot;-like visual artifact to form on the modified texture due to the way that textures are reduced. This occurs because the texture undergoing modification lacks sufficient &quot;empty space&quot; around the displayed (non-black) part of the texture (see figure 2a). To compensate for this, make the non-zero portion of the texture substantially smaller (50% of maximum stretched size -- see figure 2b) than the dimensions of the texture. Then, write a scaling function (tcScale) into the appropriate shader phase, to enlarge the image to the desired proportion.</font></p>
		<p><font size="2" face="Arial">The shaders for the bouncy pads (in the sfx.shader file) show the stretch function in use, including the scaling of the stretched texture:</font></p>
		<p><font face="Arial" size="2"><b>Example: Using clampTexCoords to control a stretching texture</b> </font></p>
		<p><font size="2">
		<table bgcolor="black" border="0" cellpadding="0" cellspacing="2" width="80%">
			<tbody>
				<tr>
					<td>
						<table bgcolor="white" border="0" cellpadding="5" cellspacing="1" width="100%">
							<tbody>
								<tr>
									<td nowrap><font face="Arial">textures/liquids/lavahell2 //path and name of new texture<br>
										{<br>
										</font>
										<table border="0" cellpadding="0" cellspacing="0">
											<tbody>
												<tr>
													<td nowrap>
														<ul>
															<li><font face="Arial"><br>
															//q3map_surfacelight 2000<br>
															surfaceparm nodamage<br>
															q3map_lightimage textures/sfx/jumppadsmall.tga<br>
															q3map_surfacelight 400<br>
															{<br>
															</font>
															<table border="0" cellpadding="0" cellspacing="0">
																<tbody>
																	<tr>
																		<td nowrap>
																			<ul>
																				<font face="Arial">map textures/sfx/metalbridge06_bounce.tga<br>
																				rgbGen identity<br>
																				</font>
																			</ul>
																		</td>
																	</tr>
																</tbody>
															</table>
															<p><font face="Arial">}<br>
															{<br>
															</font></p>
															<p>
															<table border="0" cellpadding="0" cellspacing="0">
																<tbody>
																	<tr>
																		<td nowrap>
																			<ul>
																				<font face="Arial">map $lightmap<br>
																				rgbGen identity<br>
																				blendfunc gl_dst_color gl_zero<br>
																				</font>
																			</ul>
																		</td>
																	</tr>
																</tbody>
															</table>
															</p>
															<p><font face="Arial">}<br>
															{<br>
															</font></p>
															<p>
															<table border="0" cellpadding="0" cellspacing="0">
																<tbody>
																	<tr>
																		<td nowrap>
																			<ul>
																				<font face="Arial">map textures/sfx/bouncepad01b_layer1.tga<br>
																				blendfunc gl_one gl_one<br>
																				rgbGen wave sin .5 .5 0 1.5<br>
																				</font>
																			</ul>
																		</td>
																	</tr>
																</tbody>
															</table>
															</p>
															<p><font face="Arial">}<br>
															{<br>
															</font></p>
															<p>
															<table border="0" cellpadding="0" cellspacing="0">
																<tbody>
																	<tr>
																		<td nowrap>
																			<ul>
																				<font face="Arial">clampmap textures/sfx/jumppadsmall.tga<br>
																				blendfunc gl_one gl_one<br>
																				tcMod stretch sin 1.2 .8 0 1.5<br>
																				rgbGen wave square .5 .5 .25 1.5<br>
																				</font>
																			</ul>
																		</td>
																	</tr>
																</tbody>
															</table>
															</p>
															<p><font face="Arial">}<br>
															//END<br>
															</font>
														</ul>
													</td>
												</tr>
											</tbody>
										</table>
										<p><font face="Arial">}</font></td>
								</tr>
							</tbody>
						</table>
					</td>
				</tr>
			</tbody>
		</table>
		</font></p>
		<p><font size="2" face="Arial"><b><a name="6.1.3"></a>6.1.3 AnimMap &lt;frequency&gt; &lt;texture1&gt; ... &lt;texture8&gt;</b><br>
		The surfaces in the game can be animated by displaying a sequence of 1 to 8 frames (separate texture maps). These animations are affected by other keyword effects in the same and later shader stages.</font></p>
		<p><font size="2" face="Arial"><b>&lt;Frequency&gt;:</b> the number of times that the animation cycle will repeat within a one second time period. The larger the value, the more repeats within a second. Animations that should last for more than a second need to be expressed as decimal values.</font></p>
		<p><font size="2" face="Arial"><b>&lt;texture1&gt; ... &lt;texture8&gt;: </b>the texturepath/texture name for each animation frame must be explicitly listed. Up to eight frames (eight separate .tga files) can be used to make an animated sequence. Each frame is displayed for an equal subdivision of the frequency value.</font></p>
		<p><font size="2" face="Arial"><b>Example: </b>AnimMap 0.25 animMap 10 textures/sfx/b_flame1.tga textures/sfx/b_flame2.tga textures/sfx/b_flame3.tga textures/sfx/b_flame4.tga would be a 4 frame animated sequence, calling each frame in sequence over a cycle length of 4 seconds. Each frame would be displayed for 1 seconds before the next one is displayed. The cycle repeats after the last frame in sequence is shown.</font></p>
		<p><font size="2" face="Arial"><b>Design Notes: </b>To make a texture image appear for an unequal (longer) amount of time (compared to other frames), repeat that frame more than once in the sequence.</font></p>
		<p><font size="2">
		<table bgcolor="black" border="0" cellpadding="0" cellspacing="2" width="80%">
			<tbody>
				<tr>
					<td>
						<table bgcolor="white" border="0" cellpadding="5" cellspacing="1" width="100%">
							<tbody>
								<tr>
									<td nowrap><font face="Arial">textures/sfx/flameanim_blue<br>
										{<br>
										</font>
										<table border="0" cellpadding="0" cellspacing="0">
											<tbody>
												<tr>
													<td nowrap>
														<ul>
															<font face="Arial">//*************************************************<br>
															//* Blue Flame *<br>
															//* July 20, 1999 Surface Light 1800 *<br>
															//*Please Comment Changes *<br>
															//*************************************************<br>
															qer_editorimage textures/sfx/b_flame7.tga<br>
															q3map_lightimage textures/sfx/b_flame7.tga<br>
															surfaceparm trans<br>
															surfaceparm nomarks<br>
															surfaceparm nolightmap<br>
															cull none<br>
															q3map_surfacelight 1800<br>
															// texture changed to blue flame.... PAJ<br>
															{<br>
															</font>
															<p>
															<table border="0" cellpadding="0" cellspacing="0">
																<tbody>
																	<tr>
																		<td nowrap>
																			<ul>
																				<font face="Arial">animMap 10 textures/sfx/b_flame1.tga<br>
																				textures/sfx/b_flame2.tga<br>
																				textures/sfx/b_flame3.tga<br>
																				textures/sfx/b_flame4.tga<br>
																				textures/sfx/b_flame5.tga<br>
																				textures/sfx/b_flame6.tga<br>
																				textures/sfx/b_flame7.tga<br>
																				textures/sfx/b_flame8.tga<br>
																				blendFunc GL_ONE GL_ONE<br>
																				rgbGen wave inverseSawtooth 0 1 0 10<br>
																				</font>
																			</ul>
																		</td>
																	</tr>
																</tbody>
															</table>
															</p>
															<li><font face="Arial"><br>
															}<br>
															{<br>
															</font>
															<table border="0" cellpadding="0" cellspacing="0">
																<tbody>
																	<tr>
																		<td nowrap>
																			<ul>
																				<font face="Arial">animMap 10 textures/sfx/b_flame2.tga<br>
																				textures/sfx/b_flame3.tga<br>
																				textures/sfx/b_flame4.tga<br>
																				textures/sfx/b_flame5.tga<br>
																				textures/sfx/b_flame6.tga<br>
																				textures/sfx/b_flame7.tga<br>
																				textures/sfx/b_flame8.tga<br>
																				textures/sfx/b_flame1.tga<br>
																				blendFunc GL_ONE GL_ONE<br>
																				rgbGen wave sawtooth 0 1 0 10<br>
																				</font>
																			</ul>
																		</td>
																	</tr>
																</tbody>
															</table>
															<p><font face="Arial">}<br>
															{<br>
															</font></p>
															<p>
															<table border="0" cellpadding="0" cellspacing="0">
																<tbody>
																	<tr>
																		<td nowrap>
																			<ul>
																				<font face="Arial">map textures/sfx/b_flameball.tga<br>
																				blendFunc GL_ONE GL_ONE<br>
																				rgbGen wave sin .6 .2 0 .6<br>
																				</font>
																			</ul>
																		</td>
																	</tr>
																</tbody>
															</table>
															</p>
															<p><font face="Arial">}<br>
															</font>
														</ul>
													</td>
												</tr>
											</tbody>
										</table>
										<p><font face="Arial">}</font></td>
								</tr>
							</tbody>
						</table>
					</td>
				</tr>
			</tbody>
		</table>
		</font></p>
		<p><font face="Arial"><i><b><a name="6.2"></a>6.2 Blend Functions</b></i></font><font size="2" face="Arial"><br>
		Blend functions are the keyword commands that tell the Quake III Arena graphic engine's renderer how graphic layers are to be mixed together.</font></p>
		<p><font size="2" face="Arial"><b><a name="6.2.1"></a>6.2.1 Simplified blend functions:</b><br>
		The most common blend functions are set up here as simple commands, and should be used unless you really know what you are doing.</font></p>
		<p><font size="2" face="Arial"><i><b><a name="6.2.1.1"></a>6.2.1.1 blendfunc add</b></i><br>
		This is a shorthand command for <b>blendfunc gl_one gl_one</b>. Effects like fire and energy are additive.</font></p>
		<p><font size="2" face="Arial"><i><b><a name="6.2.1.2"></a>6.2.1.2 blendfunc filter </b></i><br>
		This is a shorthand command that can be substituted for either <b>blendfunc gl_dst_color gl_zero</b> or <b>blendfunc gl_zero gl_src_color</b>. A filter will always result in darker pixels than what is behind it, but it can also remove color selectively. Lightmaps are filters.</font></p>
		<p><font size="2" face="Arial"><i><b><a name="6.2.1.3"></a>6.2.1.3 blendfunc blend </b></i><br>
		Shorthand for blendfunc gl_src_alpha gl_one_minus_src_alpha. This is conventional transparency, where part of the background is mixed with part of the texture.</font></p>
		<p><font size="2" face="Arial"><b><a name="6.2.2"></a>6.2.2 Explicit blend functions:</b><br>
		Getting a handle on this concept is absolutely key to understanding all shader manipulation of graphics. BlendFunc or &quot;Blend Function&quot; is the equation at the core of processing shader graphics. The formula reads as follows:</font></p>
		<center>
			<p><font face="Arial"><b>[Source * &lt;srcBlend&gt;] + [Destination * &lt;dstBlend&gt;]</b></font></p>
		</center>
		<p><font size="2" face="Arial"><b>Source</b> is usually the RGB color data in a texture TGA file (remember it's all numbers) modified by any rgbgen and alphagen. In the shader, the source is generally identified by command MAP, followed by the name of the image.</font></p>
		<p><font size="2" face="Arial"><b>Destination</b> is the color data currently existing in the frame buffer.</font></p>
		<p><font size="2" face="Arial">Rather than think of the entire texture as a whole, it may be easier to think of the number values that correspond to a single pixel, because that is essentially what the computer is processing ... one pixel of the bit map at a time.</font></p>
		<p><font size="2" face="Arial">The process for calculating the final look of a texture in place in the game world begins with the precalculated lightmap for the area where the texture will be located. This data is in the frame buffer. That is to say, it is the initial data in the Destination. In an unmanipulated texture (i.e.; one without a special shader script), color information from the texture is combined with the lightmap. In a shader-modified texture, the $lightmap stage must be present for the lightmap to be included in the calculation of the final texture appearance.</font></p>
		<p><font size="2" face="Arial">Each pass or &quot;stage&quot; of blending is combined (in a cumulative manner) with the color data passed onto it by the previous stage. How that data combines together depends on the values chosen for the Source Blends and Destination Blends at each stage. Remember it's numbers that are being mathematically combined together that are ultimately interpreted as colors.</font></p>
		<p><font size="2" face="Arial">A general rule is that any <b>Source Blend</b> other than <b>GL_ONE</b> (or <b>GL_SRC_ALPHA</b> where the alpha channel is entirely white) will cause the Source to become darker.</font></p>
		<p><font size="2" face="Arial"><b><a name="6.2.3"></a>6.2.3 Source Blend &lt;srcBlend&gt;</b><br>
		The following values are valid for the Source Blend part of the equation.</font></p>
		<p><font size="2">
		<table border="0" cellpadding="3" cellspacing="0">
			<tbody>
				<tr>
					<td nowrap valign="top"><font size="2" face="Arial">GL_ONE</font></td>
					<td valign="top">
						<ul>
							<font face="Arial" size="2">This is the value 1. When multiplied by the Source, the value stays the same the value of the color information does not change.</font><font face="Arial" size="2"> </font>
						</ul>
					</td>
				</tr>
				<tr>
					<td nowrap valign="top"><font size="2" face="Arial">GL_ZERO</font></td>
					<td valign="top">
						<ul>
							<font face="Arial" size="2">This is the value 0. When multiplied by the Source, all RGB data in the Source becomes Zero (essentially black).</font><font face="Arial" size="2"> </font>
						</ul>
					</td>
				</tr>
				<tr>
					<td nowrap valign="top"><font size="2" face="Arial">GL_DST_COLOR</font></td>
					<td valign="top">
						<ul>
							<font face="Arial" size="2">This is the value of color data currently in the Destination (frame buffer). The value of that information depends on the information supplied by previous stages.</font><font face="Arial" size="2"> </font>
						</ul>
					</td>
				</tr>
				<tr>
					<td nowrap valign="top"><font size="2" face="Arial">GL_ONE_MINUS_DST_COLOR</font></td>
					<td valign="top">
						<ul>
							<font face="Arial" size="2">This is nearly the same as GL_DST_COLOR except that the value for each component color is inverted by subtracting it from one. (,i.e.; R = 1.0 - DST.R, G = 1.0 - DST.G, B = 1.0 - DST.B, etc.)</font><font face="Arial" size="2"> </font>
						</ul>
					</td>
				</tr>
				<tr>
					<td nowrap valign="top"><font size="2" face="Arial">GL_SRC_ALPHA</font></td>
					<td valign="top">
						<ul>
							<font face="Arial" size="2">The TGA file being used for the Source data must have an alpha channel in addition to its RGB channels (for a total of four channels). The alpha channel is an 8-bit black and white only channel. An entirely white alpha channel will not darken the Source.</font><font face="Arial" size="2"> </font>
						</ul>
					</td>
				</tr>
				<tr>
					<td nowrap valign="top"><font size="2" face="Arial">GL_ONE_MINUS_SRC_ALPHA</font></td>
					<td valign="top">
						<ul>
							<font face="Arial" size="2">This is the same as GL_SRC_ALPHA except that the value in the alpha channel is inverted by subtracting it from one. (i.e.; A=1.0 - SRC.A)</font><font face="Arial" size="2"> </font>
						</ul>
					</td>
				</tr>
			</tbody>
		</table>
		</font></p>
		<p><font size="2" face="Arial"><b><a name="6.2.4"></a>6.2.4 Destination Blend &lt;dstBlend&gt;</b><br>
		The following values are valid for the Destination Blend part of the equation.</font></p>
		<p><font size="2">
		<table border="0" cellpadding="3" cellspacing="0">
			<tbody>
				<tr>
					<td nowrap valign="top"><font size="2" face="Arial">GL_ONE</font></td>
					<td valign="top">
						<ul>
							<font face="Arial" size="2">This is the value 1. When multiplied by the Destination, the value stays the same the value of the color information does not change.</font><font face="Arial" size="2"> </font>
						</ul>
					</td>
				</tr>
				<tr>
					<td nowrap valign="top"><font size="2" face="Arial">GL_ZERO</font></td>
					<td valign="top">
						<ul>
							<font face="Arial" size="2">This is the value 0. When multiplied by the Destination, all RGB data in the Destination becomes Zero (essentially black).</font><font face="Arial" size="2"> </font>
						</ul>
					</td>
				</tr>
				<tr>
					<td nowrap valign="top"><font size="2" face="Arial">GL_SRC_COLOR</font></td>
					<td valign="top">
						<ul>
							<font face="Arial" size="2">This is the value of color data currently in the Source (which is the texture being manipulated here).</font><font face="Arial" size="2"> </font>
						</ul>
					</td>
				</tr>
				<tr>
					<td nowrap valign="top"><font size="2" face="Arial">GL_ONE_MINUS_SRC_COLOR</font></td>
					<td valign="top">
						<ul>
							<font face="Arial" size="2">This is the value of color data currently in Source, but subtracted from one (i.e.; inverted).</font><font face="Arial" size="2"> </font>
						</ul>
					</td>
				</tr>
				<tr>
					<td nowrap valign="top"><font size="2" face="Arial">GL_SRC_ALPHA</font></td>
					<td valign="top">
						<ul>
							<font face="Arial" size="2">The TGA file being used for the Source data must have an alpha channel in addition to its RGB channels (four a total of four channels). The alpha channel is an 8-bit black and white only channel. An entirely white alpha channel will not darken the Source.</font><font face="Arial" size="2"> </font>
						</ul>
					</td>
				</tr>
				<tr>
					<td nowrap valign="top"><font size="2" face="Arial">GL_ONE_MINUS_SRC_ALPHA</font></td>
					<td valign="top">
						<ul>
							<font face="Arial" size="2">This is the same as GL_SRC_ALPHA except that the value in the alpha channel is inverted by subtracting it from one. (i.e.; A=1.0 - SRC.A).</font><font face="Arial" size="2"> </font>
						</ul>
					</td>
				</tr>
			</tbody>
		</table>
		</font></p>
		<p><font size="2" face="Arial"><b>Doing the Math: The Final Result</b><br>
		The product of the Source side of the equation is added to the product of the <b>Destination</b> side of the equation. The sum is then placed into the frame buffer to become the <b>Destination</b> information for the next stage. Ultimately, the equation creates a modified color value that is used by other functions to define what happens in the texture when it is displayed in the game world.</font></p>
		<p><font size="2" face="Arial"><b><a name="6.2.5"></a>6.2.5 Default Blend Function</b><br>
		If no blendFunc is specified then no blending will take place. A warning is generated if any stage after the first stage does not have a <b>blendFunc</b> specified.</font></p>
		<p><font size="2" face="Arial"><b><a name="6.2.6"></a>6.2.6 Technical Information/Limitations Regarding Blend Modes: </b><br>
		The Riva 128 graphics card supports ONLY the following blend modes:<br>
		GL_ONE, GL_ONE<br>
		GL_DST_COLOR, GL_ZERO<br>
		GL_ZERO, GL_SRC_COLOR<br>
		GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA<br>
		GL_ONE_MINUS_SRC_ALPHA, GL_SRC_ALPHA</font></p>
		<p><font size="2" face="Arial">Cards running in 16 bit color cannot use any GL_DST_ALPHA blends.</font></p>
		<p><font face="Arial" size="2"><i><b><a name="6.3"></a>6.3 rgbGen &lt;func&gt;</b></i></font><font size="2" face="Arial"><br>
		There are two color sources for any given shader, the texture file and the vertex colors. Output at any given time will be equal to <b>TEXTURE</b> multiplied by <b>VERTEXCOLOR</b>. Most of the time VERTEXCOLOR will default to white (which is a normalized value of 1.0), so output will be TEXTURE (this usually lands in the <b>Source</b> side of the shader equation). Sometimes you do the opposite and use TEXTURE = WHITE, but this is only commonly used when doing specular lighting on entities (i.e.; shaders that level designers will probably never create</font></p>
		<p><font size="2" face="Arial">The most common reason to use rgbGen is to pulsate something. This means that the VERTEXCOLOR will oscillate between two values, and that value will be multiplied (darkening) the texture.</font></p>
		<p><font size="2" face="Arial">If no rgbGen is specified, either &quot;identityLighting&quot; or &quot;identity&quot; will be selected, depending on which blend modes are used.</font></p>
		<p><font size="2" face="Arial">Valid &lt;func&gt; parameters are wave, <b>identity</b>, <b>identityLighting</b>, <b>entity</b>, <b>oneMinusEntity</b>, <b>fromVertex</b>, and <b>lightingDiffuse</b>.</font></p>
		<p><font size="2" face="Arial"><b><a name="6.3.1"></a>6.3.1 RgbGen identityLighting</b><br>
		Colors will be (1.0,1.0,1.0) if running without overbright bits (NT, linux, windowed modes), or (0.5, 0.5, 0.5) if running with overbright. Overbright allows a greater color range at the expense of a loss of precision. Additive and blended stages will get this by default.</font></p>
		<p><font size="2" face="Arial"><b><a name="6.3.2"></a>6.3.2 rgbGen identity</b><br>
		Colors are assumed to be all white (1.0,1.0,1.0). All filters stages (lightmaps, etc) will get this by default.</font></p>
		<p><font size="2" face="Arial"><b><a name="6.3.3"></a>6.3.3 rgbGen wave &lt;func&gt; &lt;base&gt; &lt;amp&gt; &lt;phase&gt; &lt;freq&gt;</b><br>
		Colors are generated using the specified waveform. An affected texture with become darker and lighter, but will not change hue. Hue stays constant. Note that the rgb values for color will not go below 0 (black) or above 1 (white). Valid waveforms are sin, triangle, square, sawtooth and inversesawtooth.</font></p>
		<p><font size="2" face="Arial"><b>&lt;func&gt; Wave</b> forms and their effects:</font></p>
		<ul>
			<p><font size="2" face="Arial"><b>Sin: </b>color flows smoothly through changes.<br>
			<b>Triangle: </b>color changes at a constant rate and spends no appreciable time at peaks and valleys.<br>
			<b>Square: </b>color alternates instantly between its peak and valley values.<br>
			<b>Sawtooth: </b>With a positive frequency value, the color changes at a constant rate to the peak then instantly drops to its valley value.<br>
			<b>Inversesawtooth:</b> An inverse sawtooth wave will reverse this, making the ascent immediate (like a square wave) and the decay fall off like a triangle wave.</font></p>
		</ul>
		<p><font size="2" face="Arial"><b>&lt;base&gt;</b> Baseline value. The initial RGB formula of a color (normalilzed.<br>
		<b>&lt;amp&gt;</b> Amplitude. This is the degree of change from the baseline value. In some cases you will want values outside the 0.0 to 1.0 range, but it will induce clamping (holding at the maximum or minimum value for a time period) instead of continuous change.<br>
		<b>&lt;phase&gt;</b> See the explanation for phase under the waveforms heading of Key Concepts.<br>
		<b>&lt;freq&gt;</b> Frequency. This is a value (NOT normalized) that indicates peaks per second.<br>
		</font></p>
		<p><font size="2" face="Arial"><b><a name="6.3.4"></a>6.3.4 RgbGen entity</b><br>
		Colors are grabbed from the entity's <b>modulate</b> field. This is used for things like explosions.<br>
		Design Note: This keyword would probably not be used by a level designer.</font></p>
		<p><font size="2" face="Arial"><b><a name="6.3.5"></a>6.3.5 rgbGen oneMinusEntity</b><br>
		Colors are grabbed from 1.0 minus the entity's modulate field.</font></p>
		<p><font size="2" face="Arial"><b>Design Note:</b> This keyword would probably not be used by a level designer.</font></p>
		<p><font size="2" face="Arial"><b><a name="6.3.6"></a>6.3.6 rgbGen Vertex</b><br>
		Colors are filled in directly by the data from the map or model files.</font></p>
		<p><font size="2" face="Arial"><b>Design Note:</b> rgbGen vertex should be used when you want the RGB values to be computed<br>
		for a static model (i.e. mapobject) in the world using precomputed static<br>
		lighting from Q3BSP. This would be used on things like the gargoyles, the portal frame,<br>
		skulls, and other decorative MD3s put into the Quake III Arena world.</font></p>
		<p><font size="2" face="Arial"><b><a name="6.3.7"></a>6.3.7 rgbGen oneMinusVertex</b><br>
		As rgbGen vertex, but inverted.<br>
		Design Note: This keyword would probably not be used by a level designer<br>
		</font></p>
		<p><font size="2" face="Arial"><b><a name="6.3.8"></a>6.3.8 rgbGen lightingDiffuse</b><br>
		Colors are computed using a standard diffuse lighting equation. It uses the vertex normals to illuminate the object correctly.</font></p>
		<p><font size="2" face="Arial">Design Note: - rgbGen lightingDiffuse is used when you want the RGB values to be<br>
		computed for a dynamic model (i.e. non-map object) in the world using<br>
		regular in-game lighting. For example, you would specify on shaders for<br>
		items, characters, weapons, etc.</font></p>
		<p><font face="Arial" size="2"><i><b><a name="6.4"></a>6.4 AlphaGen &lt;func&gt;</b></i></font><font size="2" face="Arial"><br>
		The alpha channel can be specified like the rgb channels. If not specified, it defaults to 1.0.</font></p>
		<p><font size="2" face="Arial"><b><a name="6.4.1"></a>6.4.1 AlphaGen portal</b><br>
		This rendering stage keyword is used in conjunction with the surface parameter keyword <b>portal</b>. The function accomplishes the &quot;fade&quot; that causes the scene in the portal to fade from view. Specifically, it means &quot;Generate alpha values based on the distance from the viewer to the portal.&quot; Use <b>alphaGen</b> portal on the last rendering pass.</font></p>
		<p><font face="Arial" size="2"><i><b><a name="6.5"></a>6.5 tcGen &lt;coordinate source&gt;</b></i></font><font size="2" face="Arial"><br>
		Specifies how texture coordinates are generated and where they come from. Valid functions are <b>base</b>, <b>lightmap</b> and <b>environment</b>.</font></p>
		<p><font size="2" face="Arial"><b>&lt;base&gt;</b> = base texture coordinates from the original art.<br>
		<b>&lt;lightmap&gt;</b> = lightmap texture coordinates<br>
		<b>&lt;environment&gt;</b> = Make this object environment mapped.<br>
		</font></p>
		<p><font size="2" face="Arial"><b><a name="6.5.1"></a>6.5.1 tcGen vector (&lt;sx&gt; &lt;sy&gt; &lt;sz&gt;) (&lt;tx&gt; &lt;ty&gt; &lt;tz&gt;)</b><br>
		New texcoord generation by world projection. This allows you to project a<br>
		texture onto a surface in a fixed way, regardless of its orientation.</font></p>
		<p><font size="2" face="Arial">S coordinates correspond to the &quot;x&quot; coordinates on the texture itself.<br>
		T coordinates correspond to the &quot;y&quot; coordinates on the texture itself.</font></p>
		<p><font size="2" face="Arial">The measurements are in game units.</font></p>
		<p><font size="2" face="Arial">Example: tcGen vector (0.01 0 0) (0 0.01 0)<br>
		This would project a texture with a repeat every 100 units across the X/Y plane.</font></p>
		<p><font face="Arial" size="2"><i><b><a name="6.6"></a>6.6 tcMod &lt;func&gt; &lt;...&gt;</b></i></font><font size="2" face="Arial"><br>
		Specifies how texture coordinates are modified after they are generated. The valid functions for tcMod are <b>rotate, scale, scroll, stretch and transform</b>. <b>Transform</b> is a function generally reserved for use by programmers who suggest that designers leave it alone. When using multiple tcMod functions during a stage, place the <b>scroll</b> command last in order, because it performs a mod operation to save precision, and that can disturb other operations. Texture coordinates are modified in the order in which tcMods are specified. In other words, if you see:</font></p>
		<p><font size="2" face="Arial"><b>tcMod scale 0.5 0.5</b><br>
		<b>tcMod scroll 1 1</b></font></p>
		<p><font size="2" face="Arial">Then the texture coordinates will be <b>scaled</b> then <b>scrolled</b>.</font></p>
		<p><font size="2" face="Arial"><b><a name="6.6.1"></a>6.6.1 tcMod rotate &lt;degrees per per second&gt;</b><br>
		This keyword causes the texture coordinates to rotate. The value is expressed in degrees rotated each second. A positive value means clockwise rotation. A negative value means counterclockwise rotation. For example &quot;tcMod rotate 5&quot; would rotate texture coordinates 5 degrees each second in a clockwise direction. The texture rotates around the center point of the texture map, so you are rotating a texture with a single repetition, be careful to center it on the brush (unless off-center rotation is desired).</font></p>
		<p><font size="2" face="Arial"><b><a name="6.6.2"></a>6.6.2 tcMod scale &lt;sScale&gt; &lt;tScale&gt;</b><br>
		Resizes (enlarges or shrinks) the texture coordinates by multiplying them against the given factors of &lt;sScale&gt; and &lt;tScale). The values &quot;s&quot; and &quot;t&quot; conform to the &quot;x&quot; and &quot;y&quot; values (respectively) as they are found in the original texture TGA. The values for <b>sScale</b> and <b>tScale</b> are NOT normalized. This means that a value greater than 1.0 will increase the size of the texture. A positive value less than one will reduce the texture to a fraction of its size and cause it to repeat within the same area as the original texture (Note: see <b>clampTexCoords</b> for ways to control this).;</font></p>
		<p><font size="2" face="Arial"><b>Example:</b> tcMod scale 0.5 2 would cause the texture to repeat twice along its width, but expand to twice its height (in which case half of the texture would be seen in the same area as the original)</font></p>
		<p><font size="2" face="Arial"><b><a name="6.6.3"></a>6.6.3 tcMod scroll &lt;sSpeed&gt; &lt;tSpeed&gt;</b><br>
		Scrolls the texture coordinates with the given speeds. ). The values &quot;s&quot; and &quot;t&quot; conform to the &quot;x&quot; and &quot;y&quot; values (respectively) as they are found in the original texture TGA, The scroll speed is measured in &quot;textures&quot; per second. A &quot;texture&quot; is the dimension of the texture being modified and includes any previous shader modifications to the original TGA). A negative s value would scroll the texture to the left. A negative t value would scroll the texture down.</font></p>
		<p><font size="2" face="Arial"><b>Example:</b> tcMod scroll 0.5 -0.5 moves the texture down and right (relative to the TGA files original coordinates) at the rate of a half texture each second of travel.</font></p>
		<p><font size="2" face="Arial">This should be the LAST tcMod in a stage. Otherwise there may be popping or snapping visual effects in some shaders.</font></p>
		<p><font size="2" face="Arial"><b><a name="6.6.4"></a>6.6.4 tcMod stretch &lt;func&gt; &lt;base&gt; &lt;amplitude&gt; &lt;phase&gt; &lt;frequency&gt;</b><br>
		Stretches the texture coordinates with the given function. Stretching is defined as stretching the texture coordinate away from the center of the polygon and then compressing it towards the center of the polygon</font></p>
		<p><font size="2" face="Arial"><b>&lt;base&gt;:</b> A base value of one is the original dimension of the texture when it reaches the stretch stage. Inserting other values positive or negative in this variable will produce unknown effects.</font></p>
		<p><font size="2" face="Arial"><b>&lt;amplitude&gt;:</b> This is the measurement of distance the texture will stretch from the base size. It is measured, like scroll, in textures. A value of 1 here will double the size of the texture at its peak.</font></p>
		<p><font size="2" face="Arial"><b>&lt;phase&gt;:</b> See the explanation for phase under the deform vertexes keyword.</font></p>
		<p><font size="2" face="Arial"><b>&lt;frequency&gt;: </b>this is wave peaks per second.</font></p>
		<p><font size="2" face="Arial"><b>Wave Functions &lt;func&gt;</b><br>
		<b>Sin wave:</b> the texture expands smoothly to its peak dimension and then shrinks smoothly to its valley dimension in a flowing manner.</font></p>
		<p><font size="2" face="Arial"><b>Triangle wave:</b> The textures stretch at a constant rate and spend no appreciable time at the peak or valley points.</font></p>
		<p><font size="2" face="Arial"><b>Square wave:</b> The texture is shown at its peak for the duration of the frequency and then at its valley for the duration of the frequency.</font></p>
		<p><font size="2" face="Arial"><b>Sawtooth: </b>the texture stretches like a triangle wave until it reaches a peak, then instantly drops to the valley, as in a square wave.</font></p>
		<p><font size="2" face="Arial"><b>Inversesawtooth: </b>this is the reverse of the sawtooth wave.</font></p>
		<p><font size="2" face="Arial"><b><a name="6.6.5"></a>6.6.5 tcMod &lt;transform&gt; &lt;m00&gt; &lt;m01&gt; &lt;m10&gt; &lt;m11&gt; &lt;t0&gt; &lt;t1&gt;</b><br>
		Transforms each texture coordinate as follows:</font></p>
		<p><font size="2" face="Arial">S' = s * m00 + t * m10 + t0<br>
		T' = t * m01 + s * m11 + t1</font></p>
		<p><font size="2" face="Arial">This is for use by programmers.</font></p>
		<p><font size="2" face="Arial"><b><a name="6.6.6"></a>6.6.6 tcMod turb &lt;base&gt; &lt;amplitude&gt; &lt;phase&gt; &lt;freq&gt;</b><br>
		Applies turbulence to the texture coordinate. Turbulence is a back and forth churning and swirling effect on the texture.</font></p>
		<p><font size="2" face="Arial">The parameters for this shader are defined as follows:</font></p>
		<p><font size="2" face="Arial"><b>&lt;base&gt;</b> Currently undefined.</font></p>
		<p><font size="2" face="Arial"><b>&lt;amplitude&gt;</b> This is essentially the intensity of the disturbance or twisting and squiggling of the texture.</font></p>
		<p><font size="2" face="Arial"><b>&lt;phase&gt;</b> See the explanation for phase under the <b>deform vertexes</b> keyword.</font></p>
		<p><font size="2" face="Arial"><b>&lt;freq&gt;</b> Frequency. This value is expressed as repetitions or cycles of the wave per second. A value of one would cycle once per second. A value of 10 would cycle 10 times per second. A value of 0.1 would cycle once every 10 seconds.</font></p>
		<p><font face="Arial" size="2"><i><b><a name="6.7"></a>6.7 depthFunc &lt;func&gt;</b></i></font><font size="2" face="Arial"><br>
		This controls the depth comparison function used while rendering. The default is &quot;lequal&quot; (Less than or equal to) where any surface that is at the same depth or closer of an existing surface is drawn. This is used for textures with transparency or translucency. Under some circumstances you may wish to use &quot;equal&quot;, e.g. for lightmapped grates that are alpha tested (it is also used for mirrors).</font></p>
		<p><font face="Arial" size="2"><i><b><a name="6.8"></a>6.8 depthWrite</b></i></font><font size="2" face="Arial"><br>
		By default, writes to the depth buffer when depthFunc passes will happen for opaque surfaces and not for translucent surfaces. Blended surfaces can have the depth writes forced with this function.</font></p>
		<p><font face="Arial" size="2"><i><b><a name="6.9"></a>6.9 Detail</b></i></font><font size="2" face="Arial"><br>
		This feature was not used in Quake III Arena maps, but should still function.</font></p>
		<p><font size="2" face="Arial">Designates this stage as a detail texture stage, which means that if the c_var, r_detailtextures, is set to 0 then this stage will be ignored (detail will not be displayed). This keyword, by itself, does not affect rendering at all. If you do put in a detail texture, it has to conform to very specific rules. Specifically, the blendFunc:</font></p>
		<p><font size="2" face="Arial"><b>blendFunc GL_DST_COLOR GL_SRC_COLOR</b></font></p>
		<p><font size="2" face="Arial">This is also the simple blend function: blendfunc filter</font></p>
		<p><font size="2" face="Arial">And the average intensity of the detail texture itself must be around 127.</font></p>
		<p><font size="2" face="Arial">Detail is used to blend fine pixel detail back into a base texture whose scale has been increased significantly. When detail is written into a set of stage instructions, it allows the stage to be disabled by the c_var console command setting &quot;r_detailtextures 0&quot;.</font></p>
		<p><font size="2" face="Arial">A texture whose scale has been increased beyond a 1:1 ratio tends not to have very high frequency content. In other words, one texel can cover a lot of real estate. Frequency is also known as &quot;detail.&quot; Lack of detail can appear acceptable if the player never has the opportunity to see the texture at close range. But seen close up, such textures look glaringly wrong within the sharp detail of the Quake III Arena environment. A detail texture solves this problem by taking a noisy &quot;detail&quot; pattern (a tiling texture that appears to have a great deal of surface roughness) and applying it to the base texture at a very densely packed scale (that is, reduced from its normal size). This is done programmatically in the shader, and does not require modification of the base texture. Note that if the detail texture is the same size and scale as the base texture that you may as well just add the detail directly to the base texture. The theory is that the detail texture's scale will be so high compared to the base texture (e.g.; 9 detail texels fitting into 1 base texel) that it is literally impossible to fit that detail into the base texture directly.</font></p>
		<p><font size="2" face="Arial">For this to work, the rules are as follows:</font></p>
		<p><font size="2" face="Arial">A.) the lightmap must be rendered first. This is because the subsequent detail texture will be modifying the lightmap in the framebuffer directly;</font></p>
		<p><font size="2" face="Arial">B.) the detail texture must be rendered next since it modifies the lightmap in the framebuffer</font></p>
		<p><font size="2" face="Arial">C.) the base texture must be rendered last ;</font></p>
		<p><font size="2" face="Arial">D.) the detail texture MUST have a mean intensity around 127-129. If it does not then it will modify the displayed texture's perceived brightness in the world</font></p>
		<p><font size="2" face="Arial">E.) the detail shader stage MUST have the &quot;<b>detail</b>&quot; keyword or it will not<br>
		be disabled if the user uses the &quot;r_detailtextures 0&quot; setting ;</font></p>
		<p><font size="2" face="Arial">F.) the detail stage MUST use &quot;blendFunc GL_DST_COLOR GL_SRC_COLOR&quot;. Any<br>
		other BlendFunc will cause mismatches in brightness between detail and non-detail views.;</font></p>
		<p><font size="2" face="Arial">G.) the detail stage should scale its textures by some amount (usually between 3 and 12) using &quot;tcMod&quot; to control density. This roughly corresponds to coarseness. A very large number, such as 12, will give very fine detail, however that detail will disappear VERY quickly as the viewer moves away from the wall since it will be MIP mapped away. A very small number, e.g. 3, gives diminishing returns since not enough is brought in when the user gets very close. I'm currently using values between 6 and 9.5. You should use non-integral numbers as much as possible to avoid seeing repeating patterns.</font></p>
		<p><font size="2" face="Arial">H.) detail textures add one pass of overdraw, so there is a definite performance hit .</font></p>
		<p><font size="2" face="Arial">I.) detail textures can be shared, so designers may wish to define only a very small handful of detail textures for common surfaces such as rocks, etc.<br>
		An example (non-existent) detail shader is as follows:</font></p>
		<p><font size="2" face="Arial"><b>Example: Texture with Detail</b><br>
		</font></p>
		<p><font size="2">
		<table bgcolor="black" border="0" cellpadding="0" cellspacing="2" width="80%">
			<tbody>
				<tr>
					<td>
						<table bgcolor="white" border="0" cellpadding="5" cellspacing="1" width="100%">
							<tbody>
								<tr>
									<td nowrap><font face="Arial">textures/bwhtest/foo<br>
										{<br>
										</font>
										<table border="0" cellpadding="0" cellspacing="0">
											<tbody>
												<tr>
													<td nowrap>
														<ul>
															<font face="Arial">// draw the lightmap first<br>
															{<br>
															map $lightmap<br>
															rgbGen identity<br>
															}<br>
															// modify the lightmap in the framebuffer by<br>
															// a highly compressed detail texture<br>
															{<br>
															map textures/details/detail01.tga<br>
															blendFunc GL_DST_COLOR GL_SRC_COLOR<br>
															// YOU MUST USE THIS!!<br>
															<br>
															detail<br>
															// for the detail to be disabled, this must be present<br>
															<br>
															tcMod scale 9.1 9.2<br>
															}<br>
															// now slap on the base texture<br>
															{<br>
															map textures/castle/blocks11b.tga<br>
															blendFunc filter<br>
															}<br>
															</font>
														</ul>
													</td>
												</tr>
											</tbody>
										</table>
										<p><font face="Arial">}</font></td>
								</tr>
							</tbody>
						</table>
					</td>
				</tr>
			</tbody>
		</table>
		</font></p>
		<p><font face="Arial" size="2"><i><b><a name="6.10"></a>6.10 alphaFunc &lt;func&gt;</b></i></font><font size="2" face="Arial"><br>
		Determines the alpha test function used when rendering this map. Valid values are GT0, LT128, and GE128. These correspond to &quot;GREATER THAN 0&quot;, &quot;LESS THAN 128&quot;, and &quot;GREATER THAN OR EQUAL TO 128&quot;. This function is used when determining if a pixel should be written to the framebuffer. For example, if GT0 is specified, the only the portions of the texture map with corresponding alpha values greater than zero will be written to the framebuffer. By default alpha testing is disabled.</font></p>
		<p><font size="2" face="Arial">Both alpha testing and normal alpha blending can be used to get textures that have see-through parts. The difference is that alphaFunc is an all-or-nothing test, while blending smoothly blends between opaque and translucent at pixel edges. Alpha test can also be used with <b>depthwrite</b>, allowing other effects to be conditionally layered on top of just the opaque pixels by setting <b>depthFunc</b> to equal.</font></p>
		<p><font size="2" face="Arial">&nbsp;</font></p>
		<p><font size="2">
		<hr>
		</font></p>
		<center>
			<p><a href="section5.htm#5"><font face="Arial" size="2">Previous</font></a><font face="Arial" size="2">&nbsp;&nbsp;&nbsp;&nbsp; <a href="index.html">Index</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="section7.htm#7">Next</a></font></p>
		</center>
		<p><font size="2">
		<hr>
		</font></p>
		<p><font face="Arial" size="2"><b>Quake 3: Arena Shader Manual Copyright 1999 id Software, Inc.<br>
		Revision 12 December 23, 1999<br>
		<br>
		</b>HTML&nbsp;by <a href="mailto:jason@heppler.com?subject=Q3A Shader Manual">Jason Heppler</a><br>
		HTML Linking by <a href="mailto:bushboy@ritualistic.com">Matthew &quot;Bushboy&quot; Trow</a><b><br>

		</b><a href="http://www.heppler.com/shader/">http://www.heppler.com/shader/</a></font>
	</body>

</html>
